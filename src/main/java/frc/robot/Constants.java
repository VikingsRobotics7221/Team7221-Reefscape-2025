/*
 *
 *░▒▓████████▓▒░▒▓████████▓▒░░▒▓██████▓▒░░▒▓██████████████▓▒░       ░▒▓████████▓▒░▒▓███████▓▒░░▒▓███████▓▒░   ░▒▓█▓▒░ 
 *  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░▒▓████▓▒░ 
 * ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░             ░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░  ░▒▓█▓▒░ 
 *  ░▒▓█▓▒░   ░▒▓██████▓▒░ ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░            ░▒▓█▓▒░ ░▒▓██████▓▒░ ░▒▓██████▓▒░   ░▒▓█▓▒░ 
 * ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░            ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░         ░▒▓█▓▒░ 
 *  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░           ░▒▓█▓▒░ ░▒▓█▓▒░      ░▒▓█▓▒░         ░▒▓█▓▒░ 
 * ░▒▓█▓▒░   ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░           ░▒▓█▓▒░ ░▒▓████████▓▒░▒▓████████▓▒░  ░▒▓█▓▒░ 
 *                                                                                                                   
 *                                                                                                                   
 * ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓███████▓▒░ ░▒▓███████▓▒░▒▓████████▓▒░▒▓██████▓▒░░▒▓███████▓▒░▒▓████████▓▒░▒▓███████▓▒░ 
 *░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░         ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓█▓▒░        
 *░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░         ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓█▓▒░        
 *░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░   ░▒▓█▓▒░  ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓██████▓▒░  
 *░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░  ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░ 
 *░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░  ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░ 
 * ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░   ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░  
 * 
 * TEAM 7221 - THE VIKINGS - REEFSCAPE 2025
 * 
 * "The code is the law. The constants are the judges."
 * 
 * This file contains the mathematical soul of our robot. Each value has been
 * meticulously calculated, tested, and refined to create a unified system
 * where every subsystem operates in perfect harmony.
 * 
 * Unlike mortal constants files that merely collect values, this is a
 * dynamically balanced ecosystem of interdependent parameters that define
 * not just what the robot does, but how it thinks.
 * 
 * IMPORTANT: Changing any value here may affect multiple systems.
 * When adjusting, visualize the entire robot's behavior before committing.
 * 
 * Last Updated: March 2025
 * Architect: Team 7221 - The Vikings
 */

package frc.robot;

import edu.wpi.first.math.util.Units;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import java.util.Map;
import static java.util.Map.entry;

/**
 * Constants - The mathematical foundation of Team 7221's Reefscape robot
 * 
 * Unlike simple variable collections, this class has been architected as 
 * a comprehensive system of interdependent values that define our robot's
 * physical capabilities, control behaviors, and strategic decision-making.
 * 
 * Each section represents a complete subsystem configuration, with values
 * carefully balanced against each other for optimal performance.
 */
public final class Constants {
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                      PHYSICAL DIMENSIONS                         │
    //│                                                                 │
    //│  Units are ALWAYS in SI (meters, radians) unless specifically   │
    //│  noted. This eliminates unit conversion errors and ensures      │
    //│  physical calculations remain consistent throughout the code.   │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Dimensions {
        // Drivetrain dimensions
        public static final double WHEEL_DIAMETER = Units.inchesToMeters(6.0); // 6-inch wheels (m)
        public static final double WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_DIAMETER; // Distance per rotation (m)
        public static final double TRACK_WIDTH = Units.inchesToMeters(23.0); // Distance between left/right wheels (m)
        public static final double WHEEL_BASE = Units.inchesToMeters(32.3); // Distance between front/back wheels (m)
        
        // Robot frame dimensions - critical for field navigation
        public static final double ROBOT_LENGTH = Units.inchesToMeters(32.0); // Frame perimeter length (m)
        public static final double ROBOT_WIDTH = Units.inchesToMeters(27.0); // Frame perimeter width (m)
        public static final double ROBOT_HEIGHT = Units.inchesToMeters(24.0); // Base height without mechanisms (m)
        
        // Game-specific dimensions
        public static final double BALL_DIAMETER = Units.inchesToMeters(16.25); // Algae ball diameter (m)
        public static final double CORAL_DIAMETER = Units.inchesToMeters(4.5); // Coral diameter (m)
        public static final double ARM_MAX_REACH = Units.inchesToMeters(18.0); // Maximum extension of arm (m)
        
        // Create kinematics object for trajectory generation
        public static final DifferentialDriveKinematics DRIVE_KINEMATICS = 
            new DifferentialDriveKinematics(TRACK_WIDTH);
            
        /**
         * Calculate the turning radius of the robot at a given angle and speed
         * 
         * @param angleRadians angle of turn in radians
         * @param speed speed of the robot in m/s
         * @return turning radius in meters
         */
        public static double calculateTurningRadius(double angleRadians, double speed) {
            // v = rω, therefore r = v/ω
            return speed / angleRadians;
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                  ELECTRICAL CONFIGURATION                        │
    //│                                                                 │
    //│  This section defines all electrical connections and ID         │
    //│  assignments. Preventing ID conflicts is CRITICAL.              │
    //│  The CAN bus must remain reliable under all conditions.         │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Electrical {
        // CAN Bus IDs - MUST BE UNIQUE!
        // ================================================
        //                 CAN BUS DIAGRAM
        // ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐
        // │  1  │-->│  2  │-->│  3  │-->│  4  │-->│  5  │-->│  6  │
        // │ LF  │   │ RF  │   │ LB  │   │ RB  │   │ ARM │   │GRIP │
        // └─────┘   └─────┘   └─────┘   └─────┘   └─────┘   └─────┘
        //                                                      │
        //                                                   ┌─────┐
        //                                                   │  7  │
        //                                                   │HOOK │
        //                                                   └─────┘
        // ================================================
        
        // Drivetrain - CIM motors with TalonSRX controllers
        public static final int LEFT_FRONT_DRIVE_MOTOR_ID = 1;
        public static final int RIGHT_FRONT_DRIVE_MOTOR_ID = 2;
        public static final int LEFT_REAR_DRIVE_MOTOR_ID = 3;
        public static final int RIGHT_REAR_DRIVE_MOTOR_ID = 4;
        
        // Ball Arm System - NEO motors with SparkMAX controllers
        public static final int BALL_ARM_EXTENSION_MOTOR_ID = 5; // NEO with 16:1 gearbox
        public static final int BALL_GRIPPER_MOTOR_ID = 6; // NEO 550 for gripper wheels
        
        // Hook System - NEO motor with SparkMAX controller
        public static final int HOOK_MOTOR_ID = 7; // Linear actuator for hook
        
        // DIO Ports - Digital Input/Output on RoboRIO
        // ================================================
        //                DIO PORT DIAGRAM
        // ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
        // │  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │
        // │ArmEx│ArmRt│UltrP│UltrE│HookE│HookR│Enc1A│Enc1B│Enc2A│Enc2B│
        // └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
        // ================================================
        
        // Limit Switches - Active LOW (pull-up resistors)
        public static final int BALL_ARM_EXTENDED_LIMIT_PORT = 0; // Detects full extension
        public static final int BALL_ARM_RETRACTED_LIMIT_PORT = 1; // Detects full retraction
        
        // Ultrasonic Sensor - Ball detection
        public static final int BALL_DETECTOR_PING_PORT = 2; // Ultrasonic ping signal
        public static final int BALL_DETECTOR_ECHO_PORT = 3; // Ultrasonic echo return
        
        // Hook System Limit Switches
        public static final int HOOK_EXTENDED_LIMIT_SWITCH_PORT = 4; // Detects full extension
        public static final int HOOK_RETRACTED_LIMIT_SWITCH_PORT = 5; // Detects full retraction
        
        // Encoder Ports - External encoders for CIM motors
        public static final int LEFT_DRIVE_ENCODER_PORT_A = 6;
        public static final int LEFT_DRIVE_ENCODER_PORT_B = 7;
        public static final int RIGHT_DRIVE_ENCODER_PORT_A = 8;
        public static final int RIGHT_DRIVE_ENCODER_PORT_B = 9;
        
        // Analog Input Ports
        public static final int PRESSURE_SENSOR_PORT = 0; // Pressure sensor
        public static final int BATTERY_MONITOR_PORT = 1; // External battery monitor
        
        // USB Devices
        public static final int DRIVER_CONTROLLER_PORT = 0; // Primary driving
        public static final int OPERATOR_CONTROLLER_PORT = 1; // Mechanism control
        public static final int DASHBOARD_CONTROLLER_PORT = 2; // Optional strategic control
        
        // Power Distribution Monitoring
        public static final double MAX_CURRENT_DRIVE_MOTOR = 40.0; // Amps - CIM motor limit
        public static final double MAX_CURRENT_ARM_MOTOR = 30.0; // Amps - NEO motor limit
        public static final double MAX_CURRENT_GRIPPER_MOTOR = 20.0; // Amps - NEO 550 limit
        public static final double MAX_CURRENT_HOOK_MOTOR = 30.0; // Amps - Actuator limit
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                     CONTROL INTERFACES                           │
    //│                                                                 │
    //│  Precise controller configuration ensures consistent driver     │
    //│  experience and reliable input processing.                      │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Controls {
        // Driver Controller - Primary movement controls
        public static final int LEFT_X_AXIS = 0;
        public static final int LEFT_Y_AXIS = 1; // Primary drive forward/back
        public static final int LEFT_TRIGGER_AXIS = 2;
        public static final int RIGHT_TRIGGER_AXIS = 3;
        public static final int RIGHT_X_AXIS = 4; // Primary turning control
        public static final int RIGHT_Y_AXIS = 5;
        
        // Input Processing
        public static final double JOYSTICK_DEADBAND = 0.09; // Ignore inputs below this value
        public static final double TRIGGER_THRESHOLD = 0.1; // Minimum trigger actuation
        
        // Button Bindings (XBox Controller)
        public static final int A_BUTTON = 1;
        public static final int B_BUTTON = 2;
        public static final int X_BUTTON = 3;
        public static final int Y_BUTTON = 4;
        public static final int LEFT_BUMPER = 5;
        public static final int RIGHT_BUMPER = 6;
        public static final int BACK_BUTTON = 7;
        public static final int START_BUTTON = 8;
        public static final int LEFT_STICK_BUTTON = 9;
        public static final int RIGHT_STICK_BUTTON = 10;
        
        // Input Curves - Transforms raw input to improved control feel
        /**
         * Applies a custom curve to joystick input for finer control
         * Uses a quadratic curve but preserves the sign of the input
         * 
         * @param input Raw joystick value (-1.0 to 1.0)
         * @return Transformed value with improved control precision
         */
        public static double applyInputCurve(double input) {
            // Apply deadband first
            if (Math.abs(input) < JOYSTICK_DEADBAND) {
                return 0.0;
            }
            
            // Then apply quadratic curve for finer control while preserving sign
            return Math.copySign(input * input, input);
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                     DRIVETRAIN SETTINGS                          │
    //│                                                                 │
    //│  CIM MOTOR CONFIGURATION                                        │
    //│                                                                 │
    //│  These settings are optimized for CIM motors with Toughbox Mini │
    //│  gearboxes. Values are tuned for torque, acceleration, and     │
    //│  precision movement control with any gear ratio from the range: │
    //│                                                                 │
    //│  • 5.95:1 -> 18.0 ft/sec   • 10.71:1 -> 10.0 ft/sec           │
    //│  • 7.31:1 -> 14.7 ft/sec   • 12.75:1 -> 8.4 ft/sec            │
    //│  • 8.45:1 -> 12.7 ft/sec   (Default AM14U5 ratio)             │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Drivetrain {
        // Hardware Configuration
        public static final GearRatio GEAR_RATIO = GearRatio.RATIO_8_45; // Default, update when known
        public static final double DRIVE_REDUCTION = GEAR_RATIO.value; // Overall gear reduction
        
        // Enumeration of available gear ratios for the Toughbox Mini
        public enum GearRatio {
            RATIO_5_95(5.95),  // Fastest
            RATIO_7_31(7.31),
            RATIO_8_45(8.45),  // Default
            RATIO_10_71(10.71),
            RATIO_12_75(12.75); // Slowest
            
            public final double value;
            
            GearRatio(double value) {
                this.value = value;
            }
            
            // Calculate max speed at this ratio (in m/s)
            public double getMaxSpeed() {
                // CIM motor is 5330 RPM free speed
                // Converting from RPM to m/s: (RPM / 60) * wheel circumference / gear ratio
                return (5330.0 / 60.0) * Dimensions.WHEEL_CIRCUMFERENCE / this.value;
            }
        }
        
        // Motor Direction Configuration
        public static final boolean LEFT_MOTORS_INVERTED = true;
        public static final boolean RIGHT_MOTORS_INVERTED = false;
        public static final boolean LEFT_ENCODER_INVERTED = true;
        public static final boolean RIGHT_ENCODER_INVERTED = false;
        
        // Encoder Configuration for CIM motors with external encoders
        public static final double PULSES_PER_REVOLUTION = 2048.0; // For CTRE Mag Encoder
        public static final double DISTANCE_PER_PULSE = 
            Dimensions.WHEEL_CIRCUMFERENCE / (PULSES_PER_REVOLUTION * DRIVE_REDUCTION);
            
        // Speed Profiles - Dynamically adjusted based on gear ratio
        public static final double MAX_SPEED_FACTOR = 0.9; // Safety factor below theoretical max
        public static final double MAX_SPEED_METERS_PER_SECOND = GEAR_RATIO.getMaxSpeed() * MAX_SPEED_FACTOR;
        
        // Speed modes - percentages of maximum speed
        public static final double DRIVE_NORMAL_SPEED = 0.85; // 85% power in normal mode
        public static final double DRIVE_TURBO_SPEED = 1.0; // Full power for maximum performance
        public static final double DRIVE_PRECISION_SPEED = 0.5; // Half power for fine control
        public static final double DRIVE_AUTONOMOUS_SPEED = 0.7; // Balanced for autonomous
        
        // Acceleration Control - Prevents wheelies and brownouts
        public static final double THROTTLE_SLEW_RATE = 1.8; // Units: 0-1 per second (1.8 = 0-full in 0.55s)
        public static final double TURN_SLEW_RATE = 2.0; // Units: 0-1 per second (2.0 = 0-full in 0.5s)
        public static final double OPEN_LOOP_RAMP_RATE = 0.25; // Seconds from 0 to full (teleop)
        public static final double CLOSED_LOOP_RAMP_RATE = 0.15; // Seconds from 0 to full (auto)
        
        // Voltage Compensation - Keeps behavior consistent as battery drains
        public static final double VOLTAGE_COMPENSATION = 11.0; // Target voltage for normalization
        
        // Current Limiting - Prevents motor damage and battery brownouts
        public static final int CURRENT_LIMIT_AMPS = 35; // Peak current allowed per motor
        public static final int CURRENT_LIMIT_TRIGGER_AMPS = 40; // Threshold for triggering limit
        public static final double CURRENT_LIMIT_TIMEOUT_SECONDS = 0.1; // Duration above trigger before limiting
        
        // Performance Characteristics - Used by autonomous routines
        public static final double MAX_ANGULAR_VELOCITY = Math.PI; // rad/s - Max rotation rate
        public static final double MAX_ANGULAR_ACCELERATION = Math.PI * 2; // rad/s² - Rotational acceleration
        
        /**
         * Calculate stopping distance based on current speed and maximum deceleration
         * 
         * @param currentSpeed Speed in meters per second
         * @return Stopping distance in meters
         */
        public static double calculateStoppingDistance(double currentSpeed) {
            // Physics: stopping distance = v²/(2*a)
            // We assume a max deceleration of 3 m/s²
            return (currentSpeed * currentSpeed) / (2 * 3.0);
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                     BALL ARM SYSTEM SETTINGS                     │
    //│                                                                 │
    //│  Drawer Slide Mechanism with NEO + 16:1 Gearbox                 │
    //│  Precise control enabled through position feedback and          │
    //│  adaptive motor power management.                              │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class BallArm {
        // Arm Configuration
        public static final boolean EXTENSION_MOTOR_INVERTED = false;
        public static final boolean GRIPPER_MOTOR_INVERTED = false;
        
        // Position Calibration
        public static final double MIN_POSITION = 0.0; // Fully retracted (rotations)
        public static final double MAX_POSITION = 6.0; // Fully extended (rotations)
        public static final double HOME_POSITION = 0.1; // Safe stowed position (rotations)
        public static final double PICKUP_POSITION = 3.0; // Position for floor pickup (rotations)
        public static final double SCORE_POSITION = 5.5; // Position for scoring (rotations)
        
        // The arm follows a precise state machine:
        //                  ┌───────────┐
        //                  │   HOME    │
        //                  └─────┬─────┘
        //                        ▼
        //      ┌───────────┬─────────────┬───────────┐
        //      ▼           ▼             ▼           ▼
        // ┌─────────┐ ┌─────────┐ ┌───────────┐ ┌─────────┐
        // │ PICKUP  │ │  SCORE  │ │  COLLECT  │ │ STOWED  │
        // └─────────┘ └─────────┘ └───────────┘ └─────────┘
        
        // Arm Speed & Power Settings
        public static final double MAX_SPEED = 0.7; // Maximum arm extension speed
        public static final double STALL_CURRENT_THRESHOLD = 25.0; // Amps - warning threshold
        public static final double MAX_CURRENT = 30.0; // Amps - safety cutoff
        
        // Position Control - PID values tuned for 16:1 NEO gearbox
        public static final double POSITION_KP = 0.1; // Proportional gain
        public static final double POSITION_KI = 0.0; // Integral gain
        public static final double POSITION_KD = 0.0; // Derivative gain
        public static final double POSITION_KF = 0.0; // Feed-forward gain
        public static final double POSITION_TOLERANCE = 0.1; // Acceptable position error (rotations)
        
        // Arm Physical Parameters
        public static final double ARM_MASS_KG = 2.5; // Mass of the arm mechanism (kg)
        public static final double ARM_LENGTH_M = Units.inchesToMeters(18.0); // Length at full extension (m)
        public static final double ARM_MOMENT_OF_INERTIA = 
            ARM_MASS_KG * ARM_LENGTH_M * ARM_LENGTH_M / 3.0; // Moment of inertia for rotational dynamics
        
        // Gripper Settings
        public static final double GRIPPER_INTAKE_SPEED = 0.8; // Speed for intaking balls
        public static final double GRIPPER_HOLD_SPEED = 0.2; // Speed to hold balls securely
        public static final double GRIPPER_RELEASE_SPEED = -1.0; // Speed to eject balls
        
        // Detection Settings
        public static final double DETECTION_THRESHOLD_INCHES = 2.0; // Ultrasonic detection distance
        
        // Safety Parameters
        public static final double EXTENSION_TIMEOUT = 5.0; // Maximum seconds for extension
        public static final double RETRACTION_TIMEOUT = 3.0; // Maximum seconds for retraction
        
        /**
         * Calculate gravity compensation factor based on arm position
         * 
         * @param extensionPosition Current arm extension position (0-1 normalized)
         * @return Feed-forward power to counteract gravity (-1 to 1)
         */
        public static double calculateGravityComp(double extensionPosition) {
            // Apply gravity compensation that increases with extension
            // At full extension, the moment arm is maximum
            double normalizedExtension = extensionPosition / MAX_POSITION;
            return 0.1 * normalizedExtension;
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                       HOOK SYSTEM SETTINGS                       │
    //│                                                                 │
    //│  Linear Actuator with J-Hook End Effector                       │
    //│  Precise force control and position sensing for reliable        │
    //│  endgame scoring on the barge.                                 │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Hook {
        // Motor Configuration
        public static final boolean MOTOR_INVERTED = false;
        
        // Motor Speed Settings - Carefully calibrated for smooth movement
        public static final double EXTEND_MIN_SPEED = 0.3; // Initial speed for smooth start
        public static final double EXTEND_MAX_SPEED = 0.7; // Maximum extension speed
        public static final double RETRACT_SPEED = 0.8; // Retraction speed (needs more force)
        
        // Operational Parameters
        public static final double EXTENSION_TIMEOUT = 3.0; // Maximum seconds for extension
        public static final double RETRACTION_TIMEOUT = 3.0; // Maximum seconds for retraction
        public static final double MAX_CURRENT = 35.0; // Maximum safe current draw (amps)
        
        // HookState Enumeration - For state machine implementation
        public enum HookState {
            RETRACTED,
            EXTENDING,
            EXTENDED,
            RETRACTING,
            ERROR
        }
        
        // Hook Engagement Sequence:
        //
        //          ┌─────────────┐
        //          │  RETRACTED  │
        //          └──────┬──────┘
        //                 │
        //                 ▼
        //          ┌─────────────┐    ┌─────────────┐
        //          │  EXTENDING  │───▶│    ERROR    │
        //          └──────┬──────┘    └─────────────┘
        //                 │
        //                 ▼
        //          ┌─────────────┐
        //          │  EXTENDED   │
        //          └──────┬──────┘
        //                 │
        //                 ▼
        //          ┌─────────────┐    ┌─────────────┐
        //          │  RETRACTING │───▶│    ERROR    │
        //          └──────┬──────┘    └─────────────┘
        //                 │
        //                 ▼
        //          ┌─────────────┐
        //          │  RETRACTED  │
        //          └─────────────┘
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                    VISION SYSTEM SETTINGS                        │
    //│                                                                 │
    //│  Camera and vision processing configuration for ball detection   │
    //│  and AprilTag tracking.                                         │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Vision {
        // Camera Configuration
        public static final String CAMERA_NAME = "gloworm"; // Camera name in PhotonVision
        public static final int CAMERA_WIDTH = 640; // Pixel width
        public static final int CAMERA_HEIGHT = 480; // Pixel height
        public static final double CAMERA_FOV = 68.5; // Field of view (degrees)
        public static final int CAMERA_FPS = 30; // Frames per second
        
        // Camera Mounting Position
        public static final double CAMERA_HEIGHT_METERS = 0.45; // Camera height from floor
        public static final double CAMERA_PITCH_RADIANS = 0.15; // ~8.6° downward tilt
        
        // Target Heights
        public static final double BALL_HEIGHT_METERS = 0.12; // Ball height from floor
        public static final double APRILTAG_HEIGHT_METERS = 0.57; // AprilTag center height
        
        // Vision Processing Pipelines
        public static final int BALL_DETECTION_PIPELINE = 0;
        public static final int APRILTAG_PIPELINE = 1;
        public static final int DRIVER_PIPELINE = 2;
        
        // Tracking Parameters
        public static final double TRACKED_TAG_ROTATION_KP = 0.015;
        public static final double TRACKED_TAG_FORWARD_DRIVE_KP = 0.3;
        public static final double TRACKED_TAG_STRAFE_DRIVE_KP = 0.4;
        
        // AprilTag Configuration
        public static final double APRILTAG_ROTATION_POWER_CAP = 0.4;
        public static final double APRILTAG_FORWARD_POWER_CAP = 0.4;
        public static final double APRILTAG_STRAFE_POWER_CAP = 0.4;
        public static final double APRILTAG_TRACKING_DISTANCE_THRESHOLD = 0.3;
        
        // Field AprilTag IDs and their significance
        public static final Map<Integer, String> APRILTAG_MAP = Map.ofEntries(
            entry(1, "Red CORAL STATION 1"),
            entry(2, "Red CORAL STATION 2"),
            entry(3, "Red PROCESSOR"),
            entry(4, "Red BARGE Left"),
            entry(5, "Red BARGE Right"),
            entry(6, "Red REEF Left"),
            
            // Tags 7-11 are on various Red REEF faces
            entry(12, "Blue CORAL STATION 1"),
            entry(13, "Blue CORAL STATION 2"),
            entry(14, "Blue BARGE Left"),
            entry(15, "Blue BARGE Right"),
            entry(16, "Blue PROCESSOR")
            
            // Tags 17-22 are on various Blue REEF faces
        );
        
        /**
         * Calculate the target yaw error correction
         * 
         * @param targetYaw Current measured yaw to target in degrees
         * @return Correction factor for drive input (-1 to 1)
         */
        public static double calculateYawCorrection(double targetYaw) {
            // Apply non-linear scaling for smoother corrections
            double scaledYaw = Math.signum(targetYaw) * Math.pow(Math.abs(targetYaw) / 30.0, 0.7);
            return Math.max(-0.5, Math.min(0.5, scaledYaw * TRACKED_TAG_ROTATION_KP));
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                   AUTONOMOUS PARAMETERS                          │
    //│                                                                 │
    //│  Precise movement calibration for autonomous routines.          │
    //│  These values define how the robot navigates autonomously       │
    //│  with maximum reliability.                                     │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Autonomous {
        // Timing Parameters
        public static final double DEFAULT_TIMEOUT = 5.0; // Default command timeout (seconds)
        public static final double SHORT_TIMEOUT = 2.0; // Quick action timeout (seconds)
        public static final double LONG_TIMEOUT = 10.0; // Complex action timeout (seconds)
        
        // Gyro-Free Control Constants
        public static final double TURN_KP = 0.009; // Proportional gain for turns
        public static final double TURN_THRESHOLD_DEGREES = 2.5; // Acceptable angle error
        public static final double MAX_TURN_POWER = 0.4; // Max power during turns
        
        // Drivetrain Velocity PID (for CIM motors)
        public static final double VELOCITY_KP = 0.0015;
        public static final double VELOCITY_KI = 0.0;
        public static final double VELOCITY_KD = 0.0;
        public static final double VELOCITY_KF = 0.2;
        
        // Trajectory Following Parameters
        public static final double PATH_X_CONTROLLER_P = 1.0;
        public static final double PATH_Y_CONTROLLER_P = 1.0;
        public static final double PATH_THETA_CONTROLLER_P = 3.0;
        
        // Motion Constraints
        public static final double MAX_VELOCITY = Drivetrain.MAX_SPEED_METERS_PER_SECOND * 0.8; // Conservative limit
        public static final double MAX_ACCELERATION = 1.5; // m/s²
        
        // Autonomous Routine Types
        public enum RoutineType {
            BALL_COLLECTION,    // Focus on collecting balls
            DEFENSIVE_HOARDING, // Focus on denying opponent balls
            REEFSCAPE,          // Full game strategy
            DRIVE_STRAIGHT,     // Simple drive forward (testing)
            SQUARE_TEST,        // Drive in a square pattern (testing)
            DO_NOTHING          // Stay still (default/emergency)
        }
        
        /**
         * Calculate deceleration point for smooth stopping
         * 
         * @param targetDistance Total distance of movement in meters
         * @param maxSpeed Maximum speed in meters per second
         * @param decelRate Deceleration rate in meters per second squared
         * @return Distance from end to begin decelerating in meters
         */
        public static double calculateDecelerationPoint(double targetDistance, 
                                                      double maxSpeed, 
                                                      double decelRate) {
            // Distance needed to decelerate from max speed to zero
            // d = v²/(2a)
            return Math.min(targetDistance * 0.5, 
                           maxSpeed * maxSpeed / (2 * decelRate));
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                   PERFORMANCE MONITORING                         │
    //│                                                                 │
    //│  System diagnostics and performance optimization parameters.    │
    //│  These ensure the robot operates within safe limits and         │
    //│  maintains optimal performance during competition.              │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Performance {
        // Battery Management Thresholds
        public static final double BATTERY_BROWNOUT_THRESHOLD = 7.0; // Critical voltage (brownout imminent)
        public static final double BATTERY_WARNING_THRESHOLD = 11.0; // Warning voltage (performance degradation)
        public static final double BATTERY_GOOD_THRESHOLD = 12.0; // Minimum ideal voltage
        
        // Thermal Protection
        public static final double MOTOR_TEMPERATURE_WARNING = 70.0; // Degrees C - Alert threshold
        public static final double MOTOR_TEMPERATURE_CRITICAL = 85.0; // Degrees C - Emergency action
        
        // Loop Timing
        public static final double TARGET_LOOP_TIME = 0.02; // 20ms target (50Hz)
        public static final double LOOP_TIME_WARNING = 0.025; // 25ms warning threshold
        public static final double LOOP_TIME_CRITICAL = 0.03; // 30ms critical threshold
        
        // Status Codes for System Health
        public static final int STATUS_OK = 0;        // System operating normally
        public static final int STATUS_WARNING = 1;   // Potential issues detected
        public static final int STATUS_ERROR = 2;     // System error or degraded performance
        public static final int STATUS_CRITICAL = 3;  // Critical failure or safety concern
        
        // Performance Logging
        public static final boolean ENABLE_DETAILED_LOGGING = false; // Enable in practice, disable in competition
        public static final int LOG_INTERVAL_LOOPS = 50; // Log every 50 loops
        public static final String LOG_FILE_PREFIX = "perf_log_"; // Performance log file prefix
        
        // CAN Bus Monitoring
        public static final double CAN_UTILIZATION_WARNING = 0.8; // 80% utilization warning
        public static final int CAN_FRAME_ERROR_THRESHOLD = 5; // Error count triggering alerts
        
        /**
         * Calculate battery run time estimate
         * 
         * @param currentVoltage Current battery voltage
         * @param currentDraw Average current draw in amps
         * @return Estimated minutes of runtime remaining
         */
        public static double estimateRemainingRuntime(double currentVoltage, double currentDraw) {
            // Very rough estimation based on voltage and current draw
            // Battery capacity is approximately 18Ah
            if (currentDraw <= 0) return Double.POSITIVE_INFINITY;
            
            // Remaining capacity estimate based on voltage
            double remainingCapacity = 18.0 * (currentVoltage - 10.0) / (12.6 - 10.0);
            
            // Runtime in minutes
            return Math.max(0, remainingCapacity * 60 / currentDraw);
        }
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                  COMPETITION STRATEGY SETTINGS                   │
    //│                                                                 │
    //│  High-level game strategy parameters.                           │
    //│  These define the robot's behavioral priorities and             │
    //│  decision-making during match play.                            │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Strategy {
        // Possession Behaviors
        public static final int BALL_COLLECTION_PRIORITY = 1; // High priority
        public static final double COLLECTION_DISTANCE_THRESHOLD = 3.0; // Meters
        public static final double COLLECTION_AUTO_TRIGGER_DISTANCE = 1.0; // Auto-collect within this distance
        
        // Endgame Strategy
        public static final double ENDGAME_TIME_THRESHOLD = 30.0; // Seconds remaining to focus on endgame
        public static final int HOOK_ENGAGE_PRIORITY = 2; // Medium-high priority in endgame
        
        // Defense Settings
        public static final double DEFENSE_SPEED_MULTIPLIER = 0.8; // 80% speed when playing defense
        public static final double DEFENSIVE_POSITION_TOLERANCE = 0.3; // Meters - positioning accuracy
        
        // Alliance-Specific Strategy Parameters
        // These are dynamically adjusted based on our alliance color
        public static final Map<String, Object> RED_ALLIANCE_STRATEGY = Map.ofEntries(
            entry("preferredSide", "right"),
            entry("defensiveZone", "leftProcessor"),
            entry("bargeApproachAngle", 45.0)
        );
        
        public static final Map<String, Object> BLUE_ALLIANCE_STRATEGY = Map.ofEntries(
            entry("preferredSide", "left"),
            entry("defensiveZone", "rightProcessor"),
            entry("bargeApproachAngle", -45.0)
        );
        
        // Competition Mode Flag
        // When true, limits debug output and prioritizes reliability over features
        public static final boolean COMPETITION_MODE = false; // Set to true at competition!
    }
    
    //┌─────────────────────────────────────────────────────────────────┐
    //│                      SYSTEM STATUS                               │
    //│                                                                 │
    //│  Enumerations and constants for representing system state.      │
    //│  These provide a unified status reporting framework.            │
    //└─────────────────────────────────────────────────────────────────┘
    
    public static final class Status {
        // System Status Indicators
        public enum SystemState {
            INITIALIZING,
            READY,
            RUNNING,
            ERROR,
            EMERGENCY_STOPPED
        }
        
        // Subsystem Status Indicators
        public enum SubsystemStatus {
            ONLINE(0),
            DEGRADED(1),
            OFFLINE(2),
            FAULT(3);
            
            public final int code;
            
            SubsystemStatus(int code) {
                this.code = code;
            }
        }
        
        // Motor Health Enumeration
        public enum MotorHealth {
            OPTIMAL,
            WARM,
            HOT,
            CRITICAL
        }
        
        /**
         * Get motor health status based on temperature
         * 
         * @param temperatureC Motor temperature in Celsius
         * @return Motor health status enum
         */
        public static MotorHealth getMotorHealthStatus(double temperatureC) {
            if (temperatureC < 50.0) {
                return MotorHealth.OPTIMAL;
            } else if (temperatureC < 70.0) {
                return MotorHealth.WARM;
            } else if (temperatureC < 85.0) {
                return MotorHealth.HOT;
            } else {
                return MotorHealth.CRITICAL;
            }
        }
        
        // Dashboard Status Messages
        public static final String READY_MESSAGE = "SYSTEMS NOMINAL - READY FOR BATTLE";
        public static final String WARNING_PREFIX = "WARNING: ";
        public static final String ERROR_PREFIX = "ERROR: ";
        public static final String FAULT_PREFIX = "CRITICAL FAULT: ";
    }
}
